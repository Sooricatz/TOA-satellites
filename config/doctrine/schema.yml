# TOA Berlin database schema, maciej@canadel.ee
#  Event's schema is mostly based on http://developer.eventbrite.com/doc/events/event_get/
#
#  INFO:
#  - If the event has paid tickets, and the user already bought the main ticket, only the free tickets should be displayed
#    (dig around their API); probably do some user flag sayign "main ticket bought"
#
#  TODO:
#  - Check if Event + Tickets are one-to-many or many-to-many?
#
#  LATER:
#  - Venue + Event - consider making it single table
#  - Optimize certain defined values basing on real world examples
#  - Add optimizations as notnulls, primary keys, indexes, etc.
options:
  charset:            UTF8
  type:               innodb

Category:
  columns:
    name:
      type: string(64)
  relations:
    Events:
      class:            Event
      local:            id
      foreign:          category_id
      type:             many

Venue:
  columns:
    eventbrite_id:
      type: integer(12) # TODO: check length
    name:
      type: string(64)
    address:
      type: string(128)
    address2:
      type: string(128)
    city:
      type: string(32)
    region:
      type: string(16)
    postal_code:
      type: integer(6)  # TODO: check for potential dashed postcodes (and either filter them out, or change this field to string)
    country:
      type: string(64)
    country_code:
      type: string(3)   # TODO: check length
    longitude:
      type: float
    latitude:
      type: float
  relations:
#    Event:
#      local:            id
#      foreign:          venue_id
#      type:             one
#      foreignType:      one
#      onDelete:         CASCADE
    Events:
      class:            Event
      local:            id
      foreign:          venue_id
      type:             many

Organiser:
  columns:
    eventbrite_id:
      type: integer(12) # TODO: check length
    name:
      type: string(64)
    description:
      type: string(256)
    url:
      type: string(128)
  relations:
    Events:
      class:    Event
      local:    id
      foreign:  organiser_id
      type:     many

EventTicket:
  columns:
    event_id:
      type: integer
      primary: true
    ticket_id:
      type: integer
      primary: true

Ticket:
  columns:
    eventbrite_id:
      type: integer(12) # TODO: check length
    type:
      type: integer(1)  # TODO: wtf is that anyway? ;)
    currency:
      type: string(3)
    price:
      type: float
    max:
      type: integer(5)  # TODO: make sure 5 digit number is enough
    min:
      type: integer(5)  # TODO: make sure 5 digit number is enough
    start_date:
      type: timestamp
    end_date:
      type: timestamp
    quantity_available:
      type: integer(5)  # TODO: make sure 5 digit number is enough
    quantity_sold:
      type: integer(5)  # TODO: make sure 5 digit number is enough
    visible:
      type: boolean
      default: false
  relations:
    Events:
      class:            Event
      refClass:         EventTicket
      foreignAlias:     Events

Attendee:
  columns:
    user_id:
      type: integer
    event_id:
      type: integer
    confirmed:
      type: boolean
      default: true # experimental
  relations:
    sfGuardUser:
      local: user_id
      foreign: id
      foreignAlias: Attendees
    Event:
      local: event_id
      foreign: id
      foreignAlias: Attendees

Event:
  columns:
    category_id:
      type: integer
      notnull: true
    eventbrite_id:
      type: integer(12)
    venue_id:
      type: integer
      notnull: true
    organiser_id:
      type: integer
      notnull: true
    title:
      type: string(64)
      notnull: true
    description:
      type: string(512)
      notnull: true
    start_date:
      type: timestamp
    end_date:
      type: timestamp
    timezone:
      type: string(32)
    url:
      type: string(128)
    capacity:
      type: integer(4)
    created:            # TODO: think about it; maybe basing on actAs Timestampable and forcing writes there would be better?
      type: timestamp
    eventbrite_modified:
      type: timestamp
    privacy:            # TODO: think about it; maybe some enumeration would be better?
      type: string(16)
    password:
      type: string(160) # TODO: check the password hashing method and adjust it
    logo:
      type: string(128)
    logo_ssl:
      type: string(128)
    status:
      type: string(16)  # TODO: think of enumeration again
    moderated:
      type: boolean
      default: false
    listing_color:
      type: string(8)
  relations:
#    Venue:
#      local: venue_id
#      foreign: id
#      type: one
#      foreignType: many
#      foreignAlias: Events
#      onDelete: CASCADE
     
    Organiser:
      local: organiser_id
      foreign: id
      onDelete: CASCADE
#    Category:
#      local: category_id
#      foreign: id
    Tickets:
      class:            Ticket
      refClass:         EventTicket
      foreignAlias:     Tickets
