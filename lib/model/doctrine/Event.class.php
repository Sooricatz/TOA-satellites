<?php

/**
 * Event
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    toaberlin
 * @subpackage model
 * @author     maciej@canadel.ee
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Event extends BaseEvent {

	public function getStartHour() {

		return date('H:i', strtotime($this->getStartDate()));
	}
	public function getEndHour() {

		return date('H:i', strtotime($this->getEndDate()));
	}
	public function toggleModerated() {

		$this->setModerated($this->getModerated() ? false : true);
		$this->save();
	}

	// # Eventbrite API methods
	public function sendToAPIForUser(sfUser $user) {

		// 0. Check if anything is actually needed here
		if($this->getSynchronized()) return true;

		// 1. Sync the organiser
		if(!$organiser_eb_id = $this->syncOrganiserForUser($user)) throw new sfException('Cannot sync Organiser with Eventbrite API!');

		// 2. Sync the venue
		if(!$venue_eb_id = $this->syncVenueForUser($user)) throw new sfException('Cannot sync Venue with Eventbrite API!');


		// 3. Sync the event
		// REMEMBER: duplicate the events, setting one as private, other one as public; private will have free tickets, while public paid
		if(!$event_eb_id = $this->syncEventForUser($user)) throw new sfException('Cannot sync Event with Eventbrite API!');
		if(!$event_eb_hidden_id = $this->syncEventForUser($user, true)) throw new sfException('Cannot sync Hidden Event with Eventbrite API!');
		$this->setSynchronized(true)->save();

		// 4. Sync the tickets (without checking the synced flags)
		if($tickets = $this->getTickets() and count($tickets)) {

			$ticket_eb_ids = array();
			$ticket_eb_hidden_ids = array();

			foreach($tickets as $ticket) {

				if(!$ticket_eb_id = $ticket->syncForUser($user)) throw new sfException('Cannot sync Ticket with Eventbrite API!');
				if(!$ticket_eb_hidden_id = $ticket->syncForUser($user, true)) throw new sfException('Cannot sync Hidden Ticket with Eventbrite API!');

				$ticket_eb_ids[] = $ticket_eb_id;
				$ticket_eb_hidden_ids[] = $ticket_eb_hidden_id;
			}
		}

		// Debug
		printf("Organiser ID: %s\nVenue ID: %s\nEvent ID: %s\nEvent Hidden ID: %s\n",

			$organiser_eb_id,
			$venue_eb_id,
			$event_eb_id,
			$event_eb_hidden_id
		);
		if(count($tickets)) {

			print "Ticket IDs:\n";
			print_r($ticket_eb_ids);

			print "Ticket Hidden IDs:\n";
			print_r($ticket_eb_hidden_ids);
		}

		// If we made it down here without exception, we surely don't have errors :)
		return true;
	}

	// Event
	// ** in this case we don't need to check the synchronized flag since if we're here, 
	//    it was certainly set to false and we need action to be taken
	// ** the $hidden flag is used for our "hidden events" workaround
	protected function syncEventForUser(sfUser $user, $hidden = false) {

		// Prepare data defaults
		$melody = $user->getMelody('eventbrite');
		$data = array(

			'title'			=> $this->getTitle(),
			'description'		=> $this->getDescription(),
			'start_date'		=> $this->getStartDate(),
			'end_date'		=> $this->getEndDate(),
			'timezone'		=> sfConfig::get('app_push_defaults_timezone'),
			'privacy'		=> 1,	// 0 for a private event, 1 for a public event
			'venue_id'		=> $this->getVenueEventbriteId(),
			'organizer_id'		=> $user->getGuardUser()->getOrganiser()->getEventbriteId(),
			'capacity'		=> $this->calculateCapacity(),
			'currency'		=> sfConfig::get('app_push_defaults_currency'),
			'locale'		=> sfConfig::get('app_push_defaults_locale'),
			'status'		=> sfConfig::get('app_push_defaults_status'),
			'confirmation_page'	=> ''	// TODO: declare it when making the buying process live
		);

		// Add the colors
		if($this->getListingColor()) {

			// TODO: colorize some fields according to http://developer.eventbrite.com/doc/events/event_new/
		}

		// Override some fields for hidden events
		if($hidden) {

			$data['privacy'] = 0;
			$data['title'] .= ' ' . sfConfig::get('app_push_defaults_attendee_suffix');
		}

		// Check for method and extra fields
		if( (!$hidden and $this->getEventbriteId()) or ($hidden and $this->getEventbriteHiddenId()) ) {

			$method = 'event_update';
			$data['id'] = $hidden ? $this->getEventbriteHiddenId() : $this->getEventbriteId();
		}
		else {

			$method = 'event_new';
			$data['personalized_url'] = sprintf('%s-%s-%s', 

				sfConfig::get('app_push_defaults_url_prefix'),
				Doctrine_Inflector::urlize($this->getTitle()),
				rand(1, 99)
			);

			// add some stuff for hidden event
			if($hidden) $data['personalized_url'] .= '-h';

			// ** the event_update method uses 'url' field, while event_new goes for 'personalized_url'; check if it matters
			// ** yet again, we will never update that url - once it is set
		}

		// Make the call
		if($return_id = $melody->analyseBasicResponse($melody->customCall($method, $data))) {

			// Save the ID for 'new' calls
			if(!$hidden and !$this->getEventbriteId()) $this->setEventbriteId($return_id);
			if($hidden and !$this->getEventbriteHiddenId()) $this->setEventbriteHiddenId($return_id);

			// Save and return the ID
			$this->save();
			return $return_id;
		}

		// Some errors occured
		else return false;
	}

	// Venue
	// ** consider if not to fetch everything and check if updates are needed! (that may actually be even more work)
	// ** also consider if not to add venue_synchronized flag (that could be a bit more work on the form saving)
	protected function syncVenueForUser(sfUser $user) {

		// Prepare data defaults to be always pushed
		$melody = $user->getMelody('eventbrite');
		$data = array(

			'name'		=> $this->getVenueName(),
			'address'	=> $this->getVenueAddress(),
			// ** we skip address2
			'city'		=> $this->getVenueCity(),
			// ** we skip region
			'postal_code'	=> $this->getVenuePostalCode(),
			'country_code'	=> sfConfig::get('app_push_defaults_country_code')
		);

		// Check for method and extra fields
		if($this->getVenueEventbriteId()) {

			$method = 'venue_update';
			$data['id'] = $this->getVenueEventbriteId();
		}
		else {

			$method = 'venue_new';
			$data['organizer_id'] = $user->getGuardUser()->getOrganiser()->getEventbriteId();
		}

		// Make the call and analyse the answer
		if($venue_eb_id = $melody->analyseBasicResponse($melody->customCall($method, $data))) {

			// Save the ID for 'new' calls
			if(!$this->getVenueEventbriteId()) $this->setVenueEventbriteId($venue_eb_id)->save();

			// Return our ID
			return $venue_eb_id;
		}

		// Some errors occured
		else return false;
	}

	// Organiser	
	protected function syncOrganiserForUser(sfUser $user) {

		$organiser = $user->getGuardUser()->getOrganiser();	// FIXME: move this code to Organiser model and then remove $organiser reference
									// FIXME: Why the fuck wont we get organiser from Event?... token keys maybe

		// Prepare data defaults
		$melody = $user->getMelody('eventbrite');
		$data = array(

			'name'		=> $organiser->getName(),
			'description'	=> !is_null($organiser->getDescription()) ? $organiser->getDescription() : 'No information provided.'
		);

		// Check for method and extra fields
		if(!$organiser->getEventbriteId()) {

			$method = 'organizer_new';
		}
		else if(!$organiser->getSynchronized()) {

			$method = 'organizer_update';
			$data['id'] = $organiser->getEventbriteId();
		}

		// ... or just return the ID and stop execution here
		else return $organiser->getEventbriteId();

		// Make the call
		if($organiser_eb_id = $melody->analyseBasicResponse($melody->customCall($method, $data))) {

			// Save the ID for 'new' calls
			if(!$organiser->getEventbriteId()) $organiser->setEventbriteId($organiser_eb_id);

			// Save and return
			$organiser->setSynchronized(true)->save();
			return $organiser_eb_id;
		}
	}

	// Helper methods
	private function calculateCapacity() {

		// If we have tickets - calculate their places sum
		if($tickets = $this->getTickets() and count($tickets)) {

			$capacity = 0;

			// FIXME: quantity_declared can be easily cheated, but on the other hand - 
			//        we can't base on the real quantity_free and quantity_paid, as
			//        those values can be different and entire API call fail
			foreach($tickets as $ticket) $capacity += $ticket->getQuantityDeclared();

			return $capacity;
		}

		// If we don't - go for defaults
		return sfConfig::get('app_push_defaults_capacity');
	}
}
