<?php

/**
 * Event
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    toaberlin
 * @subpackage model
 * @author     maciej@canadel.ee
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Event extends BaseEvent {

	public function getStartHourClean() {

		return date('H:i', strtotime($this->getStartDate()));
	}
	public function getEndHourClean() {

		return date('H:i', strtotime($this->getEndDate()));
	}

	public function toggleModerated() {

		$this->setModerated($this->getModerated() ? false : true);
		$this->save();
	}
	public function fetchMapDataPulp() {

		return array(

			'id'	=> $this->getId(),
			'lat'	=> $this->getVenueLatitude(),
			'lng'	=> $this->getVenueLongitude()
		);
	}
	public function fetchMapDataPulpEncoded() {

		return urlencode(json_encode($this->fetchMapDataPulp()));
	}

	// # Eventbrite API methods
	public function sendToAPIForUser(sfUser $user, $debug = false) {

//		$this->syncAccessCodeForUser($user);

		// 0. Check if anything is actually needed here
		if($this->getSynchronized()) return true;

		// 1. Sync the organiser (if needed)
		if(!$this->getOrganiser()->getSynchronized()) {

			if(!$organiser_eb_id = $this->getOrganiser()->syncForUser($user)) throw new sfException('Cannot sync Organiser with Eventbrite API!');	
		}
		else $organiser_eb_id = $this->getOrganiser()->getEventbriteId();

		// 2. Sync the venue
		if(!$venue_eb_id = $this->syncVenueForUser($user)) throw new sfException('Cannot sync Venue with Eventbrite API!');

		// 3. Sync the event
		if(!$event_eb_id = $this->syncEventForUser($user)) throw new sfException('Cannot sync Event with Eventbrite API!');

		// 4. Update the payment
		if(!$event_eb_payment_id = $this->syncPaymentForUser($user)) throw new sfException('Cannot sync Payment with Eventbrite API!');

		// 5. Sync the tickets and access codes
		if($tickets = $this->getTickets() and count($tickets)) {

			// 5a. The tickets
			$ticket_eb_ids = array();
			$ticket_eb_hidden_ids = array();

			foreach($tickets as $ticket) {

				if(!$ticket_eb_id = $ticket->syncForUser($user)) throw new sfException('Cannot sync Ticket with Eventbrite API!');
				if(!$ticket_eb_hidden_id = $ticket->syncForUser($user, true)) throw new sfException('Cannot sync Hidden Ticket with Eventbrite API!');

				$ticket_eb_ids[] = $ticket_eb_id;
				$ticket_eb_hidden_ids[] = $ticket_eb_hidden_id;
			}

			// 5b. The access codes
			if(!$event_eb_access_id = $this->syncAccessCodeForUser($user)) throw new sfException('Cannot sync Access Code with Eventbrite API!');
		}

		// 6. Set that we're synchronized now
		$this->setSynchronized(true)->save();

		// Debug
		if($debug) {

			printf("Organiser ID: %s\nVenue ID: %s\nEvent ID: %s\nEvent Payment ID: %s\nEvent AccessCode ID: %s\n",

				$organiser_eb_id,
				$venue_eb_id,
				$event_eb_id,
				$event_eb_payment_id,
				$event_eb_access_id
			);
			if(count($tickets)) {

				print "Ticket IDs:\n";
				print_r($ticket_eb_ids);

				print "Ticket Hidden IDs:\n";
				print_r($ticket_eb_hidden_ids);
			}
		}

		// If we made it down here without exception, we surely don't have errors :)
		return true;
	}

	// Event
	// ** in this case we don't need to check the synchronized flag since if we're here, 
	//    it was certainly set to false and we need action to be taken
	protected function syncEventForUser(sfUser $user) {

		// Prepare data defaults
		$melody = $user->getMelody('eventbrite');
		$data = array(

			'title'			=> $this->getTitle(),
			'description'		=> $this->getDescription(),
			'start_date'		=> $this->getStartDate(),
			'end_date'		=> $this->getEndDate(),
			'timezone'		=> sfConfig::get('app_push_defaults_timezone'),
			'privacy'		=> 1,
			'venue_id'		=> $this->getVenueEventbriteId(),
			'organizer_id'		=> $user->getGuardUser()->getOrganiser()->getEventbriteId(),
			'capacity'		=> $this->calculateCapacity(),
			'currency'		=> sfConfig::get('app_push_defaults_currency'),
			'locale'		=> sfConfig::get('app_push_defaults_locale'),
			'status'		=> sfConfig::get('app_push_defaults_status'),
			'confirmation_page'	=> ''	// TODO: declare it when making the buying process live
		);

		// Add the colors
		if($this->getListingColor()) {

			// TODO: colorize some fields according to http://developer.eventbrite.com/doc/events/event_new/
		}

		// Check for method and extra fields
		if($this->getEventbriteId()) {

			$method = 'event_update';
			$data['id'] = $this->getEventbriteId();
		}
		else {

			$method = 'event_new';
			$data['personalized_url'] = sprintf('%s-%s-%s', 

				sfConfig::get('app_push_defaults_url_prefix'),
				Doctrine_Inflector::urlize($this->getTitle()),
				rand(1, 99)
			);
			// ** the event_update method uses 'url' field, while event_new goes for 'personalized_url'; check if it matters
			// ** yet again, we will never update that url - once it is set
		}

		// Make the call
		if($return_id = $melody->analyseBasicResponse($melody->customCall($method, $data))) {

			// Save the ID for 'new' calls
			if(!$this->getEventbriteId()) $this->setEventbriteId($return_id);

			// Save and return the ID
			$this->save();
			return $return_id;
		}

		// Some errors occured
		else return false;
	}

	// Venue
	// ** consider if not to fetch everything and check if updates are needed! (that may actually be even more work)
	// ** also consider if not to add venue_synchronized flag (that could be a bit more work on the form saving)
	protected function syncVenueForUser(sfUser $user) {

		// Prepare data defaults to be always pushed
		$melody = $user->getMelody('eventbrite');
		$data = array(

			'name'		=> $this->getVenueName(),
			'address'	=> $this->getVenueAddress(),
			// ** we skip address2
			'city'		=> $this->getVenueCity(),
			// ** we skip region
			'postal_code'	=> $this->getVenuePostalCode(),
			'country_code'	=> sfConfig::get('app_push_defaults_country_code')
		);

		// Check for method and extra fields
		if($this->getVenueEventbriteId()) {

			$method = 'venue_update';
			$data['id'] = $this->getVenueEventbriteId();
		}
		else {

			$method = 'venue_new';
			$data['organizer_id'] = $user->getGuardUser()->getOrganiser()->getEventbriteId();
		}

		// Make the call and analyse the answer
		if($venue_eb_id = $melody->analyseBasicResponse($melody->customCall($method, $data))) {

			// Save the ID for 'new' calls
			if(!$this->getVenueEventbriteId()) $this->setVenueEventbriteId($venue_eb_id)->save();

			// Return our ID
			return $venue_eb_id;
		}

		// Some errors occured
		else return false;
	}

	// Payment
	protected function syncPaymentForUser(sfUser $user) {

		// Prepare data defaults
		$melody = $user->getMelody('eventbrite');
		$data = array(					// ** HARDCODED

			'event_id'	=> $this->getEventbriteId(),
			'accept_paypal'	=> 1,
			'paypal_email'	=> $this->getPaypal() ? $this->getPaypal() : $this->getOrganiser()->getGuardUser()->getEmailAddress()
		);

		// Save
		if($event_eb_payment_id = $melody->analyseBasicResponse($melody->customCall('payment_update', $data))) {

			if(!$this->getEventbritePaymentId() or $this->getEventbritePaymentId() != $event_eb_payment_id) $this->setEventbritePaymentId($event_eb_payment_id)->save();

			return $event_eb_payment_id;
		}

		// Errors
		else return false;
	}

	// Access code
	protected function syncAccessCodeForUser(sfUser $user) {

		// Prepare data defaults
		$melody = $user->getMelody('eventbrite');
		$data = array(

			'code'		=> $this->randString(16),
			'tickets'	=> join(',', $this->fetchHiddenTicketEventbriteIDs()),
			//'quantity_available' => 999,
			// ** we skip quantity_available
			'end_date'	=> $this->getEndDate()

		);

		// Check for method and extra fields
		if($this->getEventbriteAccesscodeId()) {

			$method = 'access_code_update';
			$data['id'] = $this->getEventbriteAccesscodeId();
		}
		else {

			$method = 'access_code_new';
			$data['event_id'] = $this->getEventbriteId();
			$data['start_date'] = date('Y-m-d H:i:s');
		}

		// Call
		if($event_eb_access_id = $melody->analyseBasicResponse($melody->customCall($method, $data))) {

			// Set the field for 'new' calls
			if(!$this->getEventbriteAccesscodeId()) $this->setEventbriteAccesscodeId($event_eb_access_id);

			// Save the access code
			$this->setEventbriteAccesscode($data['code']);

			return $event_eb_access_id;
		}

		// Errors
		else return false;
	}

	// Helper methods
	private function calculateCapacity() {

		// If we have tickets - calculate their places sum
		if($tickets = $this->getTickets() and count($tickets)) {

			$capacity = 0;

			// FIXME: quantity_declared can be easily cheated, but on the other hand - 
			//        we can't base on the real quantity_free and quantity_paid, as
			//        those values can be different and entire API call fail
			foreach($tickets as $ticket) $capacity += $ticket->getQuantityDeclared();

			return $capacity;
		}

		// If we don't - go for defaults
		return sfConfig::get('app_push_defaults_capacity');
	}
	private function fetchHiddenTicketEventbriteIDs() {

		if($tickets = $this->getTickets() and count($tickets)) {

			$hiddenIDs = array();

			foreach($tickets as $ticket) if($ticket->getEventbriteHiddenId()) $hiddenIDs[] = $ticket->getEventbriteHiddenId();

			return $hiddenIDs;
		}

		// errors?
		else return false;
	}

	// ** L8R: this method should really be elsewhere ;)
	private function randString($n=8, $chars='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890') {

		srand((double)microtime()*1000000);
		$m=strlen($chars);

		while($n--) {
			$x.=substr($chars,rand()%$m,1);
		}

		return $x;
	}
}
